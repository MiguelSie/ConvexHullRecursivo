# -*- coding: utf-8 -*-
"""Convex Hull Recursive.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NAkdLEe1VIKygQM54W6ojWSHEjPjd-RE
"""

from numpy import array
from numpy import linspace
import matplotlib as mpl
from matplotlib import pyplot as plt
import sys
import math
import numpy as np

#Función que nos da las ecuaciones de recta, que usaremos para graficar
def leqt(x1, x2, y1, y2, sw):
  if (sw != True):
    slope = (y2 - y1) / (x2 - x1)
    intercept = y1 - ( (y2 - y1) / (x2 - x1) ) * x1
    return lambda x: slope * x + intercept
  else:
    return lambda x: x1-x

#Función recursiva para hallar las rectas que son extremos del set de puntos 
#Funciona para los puntos que se hallan por encima de la recta de los puntos
#extremos en x (el menor y el mayor)
def toprecursive(P, A, B, C, sp, bp, pairs):
  min = -1
  dmax = min
  eq1 = []
  eq2 = []

  #Se halla la menor distancia usando la fórmula de distancia de un punto a una recta
  for i in range (len(P)):
    d = abs((B*P[i][0] + A*P[i][1] + C)/math.sqrt(A**2 + B**2))
    if (d>dmax):
      dmax = d
      x = P[i][0]
      y = P[i][1]
  a1 = x-sp[0]
  b1 = sp[1]-y
  c1 = (sp[0]-x)*sp[1]-b1*sp[0]

  a2 = bp[0]-x
  b2 = y-bp[1]
  c2 = (x-bp[0])*y-b2*x

  #Se evalúa en ambas rectas si aún hay puntos por encima de las mismas
  for i in range (len(P)):
    xi = P[i][0]
    yi = P[i][1]
    eq = a1*yi+b1*xi+c1
    if (eq>0):
      eq1.append(P[i])

  for i in range (len(P)):
    xi = P[i][0]
    yi = P[i][1]
    eq = a2*yi+b2*xi+c2
    if (eq>0):
      eq2.append(P[i])

  #Si hay puntos encima de la recta, se vuelve a llamar la función recursiva
  #Sino, se toma como extremo.
  if (len(eq1)>0):
    toprecursive(eq1, a1, b1, c1, sp, (x,y), pairs)
  else:
    pairs.append((sp, (x, y)))
    equations.append(leqt(sp[0], x, sp[1], y, x-sp[0]==0))
    exs.append(linspace(sp[0], x, 256))
    As.append(a1)
    Bs.append(b1)
    Cs.append(c1)
  
  if (len(eq2)>0):
    toprecursive(eq2, a2, b2, c2, (x,y), bp, pairs)
  else:
    pairs.append(((x, y), bp))
    equations.append(leqt(x, bp[0], y, bp[1], sp[0]-x==0))
    exs.append(linspace(x, bp[0], 256))
    As.append(a2)
    Bs.append(b2)
    Cs.append(c2)

#Función recursiva para hallar las rectas que son extremos del set de puntos 
#Funciona para los puntos que se hallan por debajo de la recta de los puntos
#extremos en x (el menor y el mayor)
def botrecursive(P, A, B, C, sp, bp, pairs):
  min = -1
  dmax = min
  eq1 = []
  eq2 = []

  #Se halla la menor distancia usando la fórmula de distancia de un punto a una recta
  for i in range (len(P)):
    d = abs((B*P[i][0] + A*P[i][1] + C)/math.sqrt(A**2 + B**2))
    if (d>dmax):
      dmax = d
      x = P[i][0]
      y = P[i][1]
  a1 = x-sp[0]
  b1 = sp[1]-y
  c1 = (sp[0]-x)*sp[1]-b1*sp[0]

  a2 = bp[0]-x
  b2 = y-bp[1]
  c2 = (x-bp[0])*y-b2*x

  #Se evalúa en ambas rectas si aún hay puntos por debajo de las mismas
  for i in range (len(P)):
    xi = P[i][0]
    yi = P[i][1]
    eq = a1*yi+b1*xi+c1
    if (eq<0):
      eq1.append(P[i])

  for i in range (len(P)):
    xi = P[i][0]
    yi = P[i][1]
    eq = a2*yi+b2*xi+c2
    if (eq<0):
      eq2.append(P[i])

  #Si hay puntos debajo de la recta, se vuelve a llamar la función recursiva
  #Sino, se toma como extremo.
  if (len(eq1)>0):
    botrecursive(eq1, a1, b1, c1, sp, (x,y), pairs)
  else:
    pairs.append((sp, (x, y)))
    equations.append(leqt(sp[0], x, sp[1], y, x-sp[0]==0))
    exs.append(linspace(sp[0], x, 256))
    As.append(a1)
    Bs.append(b1)
    Cs.append(c1)
  
  if (len(eq2)>0):
    botrecursive(eq2, a2, b2, c2, (x,y), bp, pairs)
  else:
    pairs.append(((x, y), bp))
    equations.append(leqt(x, bp[0], y, bp[1], sp[0]-x==0))
    exs.append(linspace(x, bp[0], 256))
    As.append(a2)
    Bs.append(b2)
    Cs.append(c2)


#Ps = [(1,6), (4, 15), (7,7), (10, 13), (11, 6), (11, 18), (11, 21), (12, 10), (15, 18), (16, 6), (18, 3), (18, 12), (19, 15), (22, 19)]
#Ps = [(14, -8), (-16, -9), (-6, 13), (15, 10), (3, 11), (-13, 8), (-15, -4), (6, 0), (12, -3), (9, -1), (-12, 5), (-5, 2), (-10, 1)]
#Ps = [(-4, -6), (-8, 0), (-16, 3), (-2, 1), (15, -1), (-7, 2), (-12, -11), (12, 10), (5, 4), (13, -14), (-15, -13), (-5, 9), (-3, 8)]
#Ps = [(-4, 13), (-5, 7), (-6, -9), (8, -1), (3, -16), (10, 15), (6, 9), (0, 5), (11, 4), (-11, -14), (-15, 14), (1, 2), (12, -2)]
#Ps = [(10, 5), (3, 7), (2, -13), (1, -14), (14, -10), (-1, -11), (9, 15), (-9, -4), (0, 6), (-16, 12), (-2, 13), (-6, 8), (-15, -8)]
Ps = [(6, 7), (3, 1), (-11, -7), (-3, -16), (-4, -1), (-5, 8), (-12, 11), (0, -10), (12, -14), (9, 10), (14, 15), (-2, -9), (-13, -6)]

newPs = []
pairs = []
topside = []
botside = []
equations = []
exs = []
As = []
Bs = []
Cs = []
angles = []

#Se organiza el set de puntos con respecto a x
Px = sorted( Ps, key = lambda t: (t[0], t[1]) )
smp = Px[0]
bsp = Px[len(Px)-1]
y2 = bsp[1]
y1 = smp[1]
x1 = smp[0]
x2 = bsp[0]
a = x2-x1
b = y1-y2
c = (x1-x2)*y1-b*x1

#Se separa el set de datos en dos conjuntos, los que están por encima y los que 
#están por debajo de la recta que pasa por el punto con menor valor en x y el 
#punto con mayor valor en x
for i in range (1, len(Px)-1):
  xi = Px[i][0]
  yi = Px[i][1]
  eq = a*yi+b*xi+c
  if (eq < 0 ):
    botside.append(Px[i])
  elif (eq > 0):
    topside.append(Px[i])

#Ambos pasan por las funciones recursivas para obtener los puntos extremos
toprecursive(topside, a, b, c, smp, bsp, pairs)
botrecursive(botside, a, b, c, smp, bsp, pairs)

#Se grafica
fig, ax = plt.subplots()
for i in range(len(equations)):
  x = exs[i]
  y = equations[i](x)
  ax.plot(x, y, color='black')

ps = array(Ps)
xi, yi = ps[:, 0], ps[:, 1]
ax.plot(xi, yi, linestyle='', color='red', marker='*', markersize=12)

print(pairs)
pairsL = []
pairsR = []

#Se consiguen aquellos que no hacen parte de los extremos
for i in range(len(pairs)):
  pairsL.append(pairs[i][0])

for i in range(len(pairs)):
  pairsR.append(pairs[i][1])

for i in range(len(Ps)):
  if Ps[i] not in pairsL and Ps[i] not in pairsR:
    newPs.append(Ps[i])
print(len(newPs))

#Se saca el promedio de distancias de los puntos internos a todas las rectas
d = 0
cont = 0
for i in range(len(As)):
  for j in range(len(newPs)):
    daux = abs((Bs[i]*newPs[j][0] + As[i]*newPs[j][1] + Cs[i])/math.sqrt(As[i]**2 + Bs[i]**2))
    d = d + daux
    cont = cont + 1
print(d, cont)
print(d/cont)


#El promedio de largo de los extremos del convex hull
d = 0
cont = 0
for i in range(len(pairs)):
  daux = np.sqrt((pairs[i][0][0] - pairs[i][1][0])**2 + (pairs[i][0][1] - pairs[i][1][1])**2)
  d = d+daux
  cont = cont+1
print(d, cont)
print(d/cont)

#Ángulo promedio de los ángulos internos del convex hull
avrg_angle = 180*(len(pairs)-2)/len(pairs)
print(avrg_angle)